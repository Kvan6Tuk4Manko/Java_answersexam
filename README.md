## 1. Введение в Java. Основные характеристики языка, сферы применения, история создания. Экосистема языка JAVA. JDK, JRE, JVM. 
- Простой - построен на основе языка C++, но значительно упрощен
- Объектно-ориентированный - Java с самого начала проектировался как объектно-ориентированный
- Распределенный - разработан для упрощения распределенных вычислений
- Интерпретируемый - для запуска необходим интерпретатор
- Надежный - Java-компиляторы могут обнаружить множество проблем
- Безопасный - несколько механизмов безопасности
- Кросс-платформенный - «Один раз напишите, везде запустите»
- Высокопроизводительный - достаточная скорость для интерактивных приложений, где центральный процессор простаивает
- Многопоточный - многопоточное программирование плавно интегрировано в Java
- Динамичный - новые функциональные возможности Java могут прозрачно встраиваться
---
- Java — это мощный и универсальный язык программирования
для разработки программного обеспечения, работающего на
мобильных устройствах, встраиваемых системах, настольных
компьютерах, серверах и т.д.

- Важные системы: банковские терминалы, системы обработки
транзакций, сервисы координации перелетов и другие.
---
- Java Development Kit (JDK) – это программный комплект, который предоставляет всё необходимое для разработки и компиляции Java-приложений.
- Java Runtime Environment (JRE) – это окружение, необходимое для выполнения Java-программ.
- Java Virtual Machine (JVM) – это центральный компонент платформы Java, который обеспечивает независимость кода от конкретной операционной системы и аппаратной архитектуры. JVM является частью JRE.

## 2. Основные платформы Java. Java SE, Java EE, Java ME, их особенности и области применения. 
- Java Card - создание приложений для смарт-карт и других устройств с ограниченными вычислительными ресурсами.
- Java Standard Edition (Java SE)-разработка настольных и серверных приложений. Она предоставляет стандартные библиотеки и API для создания полнофункциональных приложений.
- Java Micro Edition (Java ME) - создание приложений, работающих на мобильных устройствах, встроенных системах и т.д.
- Java Enterprise Edition (Java EE) - создания масштабируемых, надёжных и управляемых корпоративных приложений

## 3. Виртуальные машины и их роль в JAVA. Архитектура JVM. Основные компоненты: Class Loader, Execution Engine, Garbage Collector.
- В Java можно использовать различные реализации виртуальных машин, хотя наиболее широко распространенной и часто используемой является стандартная JVM (Java Virtual Machine), поставляемая с Oracle JDK или OpenJDK.
- OpenJ9
- GraalVM
- Zulu JVM
- Kotlin/Native(не является полной заменой JVM)
- Роль JVM: Обеспечить переносимость кода на различные платформы.
---
- Class Loader - модуль, который отвечает за загрузку классов в память. Class Loader выполняет динамическую загрузку классов во время выполнения программы и позволяет JVM загружать классы из различных источников, таких как файловая система или сеть.
- Execution Engine -модуль, который отвечает за выполнение байт-кода. Execution Engine может использовать интерпретацию байт-кода или Just-In-Time (JIT) компиляцию для преобразования байт-кода в машинный код и его выполнения.
- Garbage Collector (GC) - механизм автоматического управления памятью, который освобождает память, занимаемую объектами, которые больше не используются программой. GC помогает избежать утечек памяти и обеспечивает стабильную работу приложений.

## 4. Компиляция Java-программ. Различия между JIT (Just-in-Time) и AOT (Ahead-of-Time) компиляцией. Преимущества и недостатки. 
- Компиляция Ahead-of-Time (AOT) и компиляция Just-in-Time (JIT) в Java представляют собой два разных метода преобразования байт-кода Java в машинный код, но применяются они на разных этапах жизненного цикла программы и имеют разные цели.
- JIT-компиляция (Just-in-Time) — это процесс компиляции байт-кода Java в машинный код непосредственно во время выполнения программы. Когда программа запускается, байт-код интерпретируется JVM, и по мере необходимости определенные участки кода компилируются в машинный код "на лету" (just-in-time), чтобы повысить производительность.
- AOT-компиляция — это процесс компиляции байт-кода Java в машинный код до запуска программы. В отличие от JIT, который компилирует код "на лету", AOT-компиляция производится заранее, например, во время сборки или установки приложения.

## 5. Модель памяти в Java. Основные области памяти JVM: куча (Heap) и стек (Stack), их назначение и различия. Как распределяются объекты и примитивные данные в этих областях? Что такое Young Generation, Old Generation и Metaspace? Как работа сборщика мусора влияет на управление памятью?
- Java предоставляет автоматическое управление памятью
---
- Heap (Куча) - это область памяти, где хранятся все объекты и массивы, создаваемые в Java-программе с использованием ключевого слова new. Управление памятью в куче осуществляется автоматически с помощью сборщика мусора.
- Stack (Стек) - используется для хранения примитивных типов данных (например, int, float, char) и ссылок на объекты в куче. Каждый поток имеет свой собственный стек, который управляет вызовами методов, их параметрами, локальными переменными и возвращаемыми значениями. В отличие от кучи, память в стеке выделяется и освобождается автоматически, при вызове и завершении методов.
---
- Young Generation (Молодое поколение)
- Old Generation (Старое поколение)
- Permanent Generation (Metaspace в Java 8 и выше)
- PermGen (Permanent Generation) — это специальное место в куче, отделенное от основной памяти. Здесь виртуальная машина хранит метаданные загруженных классов. Полностью удалена в JDK 8.
- Metaspace – новая область памяти, заменившая устаревшую PermGen. Основное их отличие заключается в способе распределения памяти. Metaspace выделяется из памяти нативной ОС, а не из памяти JVM. Это улучшило масштабируемость.
---
- Освобождение памяти происходит автоматически с помощью встроенного сборщика мусора.
- Сборщик мусора (garbage collector) автоматически проверяет область памяти, где живут объекты Java – Java Heap (куча) – и уничтожает их, если они стали не нужны программе.
- Алгоритм работы сборщика мусора зависит от конкретной платформы – а значит, конкретной JVM

## 6. Основные парадигмы программирования в Java. Объектно-ориентированное, функциональное, многопоточное программирование.
О парадигмах программирования в JAVA
- Java поддерживает несколько парадигм программирования, что делает её мощным и универсальным языком.
- Императивное программирование - Java поддерживает императивный стиль
- Обобщенное программирование (Generic Programming) - Java поддерживает обобщённое программирование через использование дженериков (generics).
- Реактивное программирование - через сторонние библиотеки, такие как Project Reactor или RxJava.
---
- Объектно-ориентированное программирование (ООП) - основная парадигма, на которой построена Java.
- Функциональное программирование - начиная с версии Java 8, язык добавил поддержку функционального программирования.
- Многопоточное программирование - Java предлагает встроенные средства для разработки многопоточных программ, что является частью парадигмы конкурентного программирования.

## 7. Виртуальные машины и их роль в JAVA. Особенности стандартной HotSpot JVM. GraalVM и другие сторонние виртуальные машины для Java. Основные преимущества и возможности сторонних виртуальных машин.
- В Java можно использовать различные реализации виртуальных машин, хотя наиболее широко распространенной и часто используемой является стандартная JVM (Java Virtual Machine), поставляемая с Oracle JDK или OpenJDK.
- OpenJ9
- GraalVM
- Zulu JVM
- Kotlin/Native(не является полной заменой JVM)
- Роль JVM: Обеспечить переносимость кода на различные платформы.
---
JIT-компиляция(HotSpot JIT)
- JIT-компиляция (Just-in-Time) — это процесс компиляции байт-кода Java в машинный код непосредственно во время выполнения программы. Когда программа запускается, байт-код интерпретируется JVM, и по мере необходимости определенные участки кода компилируются в машинный код "на лету" (just-in-time), чтобы повысить производительность.
- На текущий момент в JVM многоуровневая компиляция (tiered compilation). Существует не один, а два компилятора: C1 и C2.
---
GraalVM
- Это многофункциональная виртуальная машина, основанная на HotSpot/OpenJDK и написанная на Java и разработанная для запуска приложений, написанных на разных языках программирования, с высокой производительностью и возможностью выполнения кода на различных платформах.
---
Основные преимущества и возможности сторонних виртуальных машин
- Высокая производительность: Многие сторонние JVM предлагают более высокую производительность по сравнению с HotSpot, особенно в специфических сценариях использования.
- Новые возможности: Сторонние JVM могут предоставлять новые функции и возможности, которые отсутствуют в HotSpot.
- Специализация: Некоторые JVM специализируются на определенных типах приложений, таких как серверные приложения или приложения с низкой задержкой.
- Инновации: Сторонние JVM часто являются площадкой для экспериментов и внедрения новых технологий
## 8. Компиляция и запуск проекта на Java. Обеспечение переносимости кода на различные платформы. Понятие промежуточного байт-кода и его роль в переносимости программ. Чем отличаются методы компиляции JIT (Just-In-Time) и AOT (Ahead-of-Time), и как они влияют на производительность и переносимость?
- Java является языком программирования, который сочетает в себе как компиляцию, так и интерпретацию.
---
- Компиляция Ahead-of-Time (AOT) и компиляция Just-in-Time (JIT) в Java представляют собой два разных метода преобразования байт-кода Java в машинный код, но применяются они на разных этапах жизненного цикла программы и имеют разные цели.

## 9. Современный инструментарий разработчика Java. Популярные IDE и их возможностей для написания, отладки и сборки кода. Основные системы сборки и их роль в управлении проектами на JAVA. Контроль версий с использованием Git и интеграция с платформами хостинга ИТ-проектов. Использование Docker и Kubernetes для контейнеризации и оркестрации приложений. Инструменты CI/CD  для автоматизации сборки, тестирования и деплоя JAVA приложений.
- Среда разработки (IDE) — это ключевой инструмент Java-разработчика, который предоставляет удобный интерфейс для написания, отладки и сборки кода. (IntelliJ IDEA, Eclipse, Apache NetBeans)
- Системы сборки автоматизируют процесс компиляции, тестирования и упаковки приложений, а также управления зависимостями. (Maven, Gradle, Ant)
- Контроль версий (Git, GitHub, GitLab, Bitbucket.)
- Инструменты для тестирования. Java предлагает широкий спектр инструментов для написания и автоматизации тестов (JUnit, TestNG, Mockito)
- Инструменты для непрерывной интеграции и деплоя (CI/CD). CI/CD инструменты помогают автоматизировать процесс сборки, тестирования и деплоя приложений. (Jenkins, GitLab CI, CircleCI)
- Контейнеризация и оркестрация помогают разрабатывать, тестировать и деплоить Javaприложения в изолированных средах. (Docker, Kubernetes)

## 10. Современные фреймворки для разработки на Java. Особенности Spring Framework. Основные возможности Hibernate. Основные причины использования данных фреймворков при разработке на JAVA.
Фреймворки JAVA
- Spring Framework - один из самых популярных и мощных фреймворков в экосистеме Java. Разработан в 2003 году для упрощения разработки корпоративных приложений на Java.
---
Hibernate выступает посредником между кодом и базой данных, позволяя легко настраивать преобразование объектов вручную
1. ускоряет написание кода;
2. создаёт удобную модель отображения уже существующей базы внутри кода;
3. позволяет задать стандарт переноса информации из кода в БД

## 11. Объектная модель Java. Основные принципы объектной модели в Java: классы, объекты, интерфейсы, наследование и инкапсуляция. Класс Object и методы, которые он предоставляет.
- Java объектный язык следовательно он оперирует объектами
- Все сущности в Java являются объектами, классами либо интерфейсами.
- На вершине иерархии класс Object, у которого много методов: String toString(), boolean equals(Object o), Object clone(), int hashCode()
- Все объекты, которые вы будете создавать являются потомками класса Object
- Вы можете переопределить методы класса Object в с воем классе пользовательском классе
- Строгая реализация инкапсуляции.
- Реализовано одиночное наследование от класса и множественное от интерфейсов.

## 12. Пакеты в Java. Основное предназначение. Структура, организация, использование в программировании (импорт пакетов).
- Пакет (package) — это именованное пространство, которое группирует схожие по функциональности классы и интерфейсы.
- Помогают структурировать код, избегать конфликтов имен и контролировать видимость классов и методов.
- В состав пакетов входят:
- классы;
- интерфейсы;
- вложенные пакеты.
---
- Структура пакетов. Имя пакета обычно соответствует структуре каталогов в файловой системе. Например, для пакета com.example.myapp, исходный файл MyClass.java должен располагаться в каталоге com/example/myapp.
- Пакеты могут быть вложенными, что позволяет создавать иерархию пакетов. Например:
- com.example: базовый пакет.
- com.example.myapp: подпакет внутри com.example.
- com.example.myapp.utils: вложенный пакет внутри com.example.myapp.
---
Импорт пакетов
- ключевое слово import
- можно импортировать все классы иинтерфейсы из пакета, используя
символ звёздочки *. Предпочтительно
использовать явный импорт конкретных
классов.
- ВАЖНО! Пакет java.lang автоматически
импортируется в каждую программу
Java по умолчанию. Это значит, что вы
можете использовать классы из java.lang
без явного импорта.

## 13. Синтаксис и лексика Java. Основные элементы лексики языка: ключевые слова, идентификаторы, литералы, комментарии, операторы и разделители. Правила именования идентификаторов. Соглашения по оформлению кода.
Лексика — это совокупность
правил, определяющих допустимые
элементы программы на уровне
символов, слов и простых
выражений.
- Ключевые слова
- Идентификаторы
- Литералы
- Комментарии
- Операторы
- Разделители

Синтаксис Java — это набор правил,
определяющих правильное
построение программ на языке
Java.
- Структура программы
- Объявление классов и методов
- Переменные и типы данных
- Циклы
- Методы
---
- Ключевые слова в Java — это зарезервированные слова, которые имеют
специальное значение и используются для определения структуры и
поведения программы.
- Нельзя использовать в качестве идентификаторов (например, имен
переменных, методов, классов и т.д.)
---
- Идентификаторы для переменных
- Идентификаторы для методов
- Идентификаторы для классов и
интерфейсов
- Идентификаторы для пакетов
- Идентификаторы для констант
--- 
Соглашения по оформлению кода Java
(Java Code Conventions) - это набор рекомендаций и стандартов по
написанию кода на языке Java,
разработанный компанией Sun
Microsystems.

## 14. Типы данных в Java. Примитивные типы данных, объявление и присваивание переменных. Отличия примитивных типов данных от ссылочных.
Примитивные(базовые)
- Вещественные
- Целочисленные
- Логические

Ссылочные(объектные)
- Различные типы данных и интерфейсов
- Переменная ссылочного
- null

Целочисленные типы данных:
- byte – 8-битовое целое число со знаком(-128 до 127),
- short – 16-битовое целое число со знаком(от -32,768 до 32,767),
- int – 32-битовое целое число со знаком(-2,147,483,648 до 2,147,483,647),
- long – 64-битовое целое число со знаком(-9,223,372,036,854,775,808 до
9,223,372,036,854,775,807)



## 15. Типы данных в Java. Ссылочные типы данных, объявление и присваивание переменных. Отличия ссылочных типов данных от примитивных. Роль классов-оберток (Wrapper Classes) для работы с примитивами.
Примитивные(базовые)
- Вещественные
- Целочисленные
- Логические

Ссылочные(объектные)
- Различные типы данных и интерфейсов
- Переменная ссылочного
- null

Ссылочные(объектные) типы данных
- В Java все объектные типы данных являются ссылочными типами. Это
означает, что переменные объектных типов всегда хранят ссылки на
объекты, а не сами объекты.

## 16. Константы в Java. Понятие констант и их объявление с использованием ключевого слова final. Основные правила и соглашения по именованию констант. Примеры создания констант для примитивных типов данных и строк. Как константы помогают обеспечить неизменность данных и улучшают читаемость кода?
Модификатор final
- Когда переменная объявляется как final, она может быть 
инициализирована только один раз. После этого ее 
значение не может быть изменено.
- Переменные могут быть локальными (в методах) или 
полями класса
```Java
final int MAX_VALUE = 100
```

## 17. Ключевое слово var в Java. Особенности использования var для объявления локальных переменных. Как происходит неявное выведение типа переменной компилятором? Ограничения на использование var: недопустимость для полей класса, параметров методов и возвращаемых типов.
- Улучшение читаемости кода, упрощение написания кода
- Неявное выведение типов или объявления переменных без явного указания 
типа 
- var используется только для локальных переменных, объявленных внутри 
методов, блоков или лямбда-выражений. Не может быть использовано для 
полей класса, параметров методов или возвращаемых типов.
```Java
var message = "Hello, world!"
```
## 18. Соглашения по оформлению кода Java. Java Code Conventions и её значение для совместной работы.
- Это набор рекомендаций и стандартов по
написанию кода на языке Java,
разработанный компанией Sun
Microsystems.
- Следование этим стандартам также
упрощает процесс чтения и понимания
кода другими разработчиками.
---
Инстанцирование
 происходит, когда 
используется ключевое 
слово new для создания 
объекта в памяти


## 19. Класс и экземпляры класса. Что такое класс в Java и как происходит создание объектов (инстанцирование) с использованием ключевого слова new? Примеры создания и использования экземпляров класса.
- Класс — это шаблон 
или модель (blueprint), 
которая определяет 
структуру и поведение 
объектов
- Экземпляр объекта —
это конкретная 
реализация (instance) 
класса, созданная в 
памяти программы
```Java
Car car1 = new Car("Toyota", 2020)
```

## 20. Записи (Records) в Java. Какие возможности они предоставляют и в чем их отличие от обычных классов? Примеры использования записей.
Развивает идею pattern matching
- Предназначены для создания неизменяемых 
(immutable) классов данных, которые автоматически 
предоставляют стандартные реализации таких 
методов, как equals(), hashCode(), toString() и 
автоматическую инициализацию полей.
- Цель — сократить количество шаблонного кода
```Java
public record OrderMessage(Long orderId, String product, int quantity) {
}
```

## 21. Запечатанные (Sealed) классы. Как они ограничивают наследование и для чего используются?
- Запечатанный (sealed) класс позволяет 
ограничивать или выбирать подклассы. Класс не 
может расширять закрытый класс, если его нет в 
списке разрешенных дочерних классов 
родительского класса
```Java
public sealed class Shape permits Circle, Rectangle, Triangle {
// Общие свойства и методы для всех фигур
}
```
---
- Запечатанный (sealed) 
класс позволяет 
ограничивать или 
выбирать подклассы. Класс 
не может расширять 
закрытый класс, если его 
нет в списке разрешенных 
дочерних классов 
родительского класса.



## 22. Инкапсуляция в Java. Понятие инкапсуляции как механизма защиты данных и управления доступом к ним. Реализация инкапсуляции с использованием модификаторов доступа (private, protected, public, package-private). Роль геттеров и сеттеров в обеспечении контроля за изменением данных объекта. Примеры нарушения инкапсуляции и способы предотвращения этих ошибок.
- Цель инкапсуляции —
защитить данные и 
внутренние детали 
реализации объектов от 
прямого доступа и 
изменений извне
---
Public (публичный доступ)
- Поля или методы, объявленные как public, доступны из любого 
места в программе — как внутри одного класса или пакета, так и 
за его пределами. Это наиболее открытый уровень доступа.

Private (приватный доступ)
- Поля или методы, объявленные как private, доступны только 
внутри класса, в котором они объявлены. Это наиболее строгий 
уровень доступа

Protected (защищенный доступ)
- Поля или методы, 
объявленные как 
protected, доступны 
внутри одного и того же 
пакета, а также в 
подклассах, даже если 
эти подклассы находятся 
в других пакетах

Модификатор по умолчанию
- Если модификатор доступа не указан, доступ считается 
package-private (доступ внутри пакета). Это означает, что 
поля и методы доступны только для классов, находящихся в 
том же пакете.
---
Стандартные методы класса Геттеры и Cеттеры
- Геттеры и сеттеры — это стандартные методы, которые 
обеспечивают доступ к полям (свойствам) объекта класса.
- Геттеры — это методы, предназначенные для получения значения приватного поля 
класса. Обычно они объявляются как public и возвращают значение 
соответствующего поля.
- Сеттеры — это методы, предназначенные для изменения значения приватного поля 
класса. Обычно объявляются как public и позволяют изменить значение поля с 
помощью переданного аргумента.


## 23. Модификаторы доступа. Какие уровни доступа существуют в Java? Как модификаторы доступа используются для контроля видимости классов, полей и методов?
## 24. Модификатор final. Применение final к переменным, методам и классам. Как он предотвращает изменения данных, поведение методов и наследование? 
## 25. Конструкторы в Java. Понятие конструктора и его роль в создании объектов. Различия между конструктором и методом. Типы конструкторов. Как реализовать перегрузку конструкторов? 
## 26. Конструкторы в Java. Понятие конструктора и его роль в создании объектов. Использование ключевого слова this для вызова одного конструктора из другого. Особенности работы конструкторов в наследовании, вызов конструктора родительского класса через super.
## 27. Блоки инициализации. Виды блоков инициализации: статические и нестатические. Их роль в подготовке объектов и классов. Примеры использования блоков для сокращения повторяющегося кода.
## 28. Статические блоки инициализации. Примеры и использование статических блоков для выполнения кода при загрузке класса. Их роль в инициализации общих данных.
## 29. Модификатор static. Особенности использования static для полей, методов и блоков. Различия между статическими и нестатическими членами класса. Примеры применения для создания общих ресурсов.
## 30. Ключевое слово this. Использование this для доступа к полям и методам объекта, вызова других конструкторов и передачи текущего объекта. Примеры решения конфликтов имен с помощью this.
## 31. Концепция неизменяемых классов. Что делает класс неизменяемым? Использование final для предотвращения изменений. Примеры создания неизменяемых объектов.
## 32. Создание объектов. Отличие фабричных методов от стандартного создания объектов с использованием new. Примеры использования фабричных методов.
## 33. Рефлексия в Java. Возможности рефлексии для создания объектов и вызова методов во время выполнения. Примеры использования рефлексии для создания объектов.
## 34. Жизненный цикл объектов в JAVA. Роль сборщика мусора в управлении памятью. Примеры оптимизации работы объектов в Java.
## 35. Инициализация переменных в JAVA. Способы инициализации переменных: по умолчанию, в конструкторах, через блоки инициализации. Примеры применения.
## 36. Математические функции. Класс Math в Java и его методы для выполнения вычислений. Примеры использования тригонометрических и экспоненциальных функций в задачах. Нужно ли создавать объект класса Math для использования математических методов.

## 37. Абстракция и инкапсуляция класса. Понятие абстракции как отделения реализации класса от его использования. Как эти принципы улучшают структурирование кода и его модульность? 
## 38. Отношения между классами. Основные виды отношений между классами: ассоциация, агрегация, композиция, наследование.
## 39. Ассоциация. Понятие ассоциации как бинарного отношения между классами. Примеры реализации ассоциации в Java. Как ассоциация помогает моделировать взаимодействие объектов?
## 40. Агрегация и композиция. Понятия агрегации и композиции, их различия. Как они отражают отношения «has-a» между объектами? Примеры реализации агрегации и композиции в проектировании классов.
## 41. Обработка примитивных типов как объектных. Использование классов-оберток для работы с примитивными типами как с объектами. Примеры преобразования примитивных типов в объекты и обратно. 
## 42. Классы-обертки. Основные возможности классов-оберток: Integer, Double, Boolean и других. Методы для преобразования значений и сравнения объектов. Примеры использования методов parseInt, valueOf и compareTo.
## 43. Автоматическое преобразование. Что такое автоупаковка (autoboxing) и автораспаковка (unboxing) в Java? Как они автоматически преобразуют значения примитивных типов в объекты и обратно? Примеры использования.
## 44. Класс String. Понятие неизменяемости(иммутабельности) строк в Java. Как создаются объекты типа String? Примеры работы с методами создания, сравнения и модификации строк.
## 45. Строки в JAVA. Замена и разделение строк. Методы класса String для замены символов и разделения строк. Примеры работы с методами replace и split.
## 46. Строки в JAVA. Преобразования между строками и массивами. Как преобразовать строку в массив символов и наоборот? Примеры использования методов toCharArray и valueOf.
## 47. Строки в JAVA. Класс StringBuilder и StringBuffer. Понятие изменяемых строк. Основные отличия между StringBuilder и StringBuffer. Примеры их использования. Влияние классов StringBuilder и StringBuffer на типобезопасность.
## 48. Строки в JAVA. Преобразование символов и чисел в строки. Какие методы используются для преобразования чисел, символов и объектов в строки? Примеры работы с методами String.valueOf() и toString().
## 49. Строки в JAVA. Интернированные строки. Что такое интернированные строки? Как JVM оптимизирует работу с повторяющимися строками? Примеры их использования.
## 50. Наследование в JAVA. Основные принципы наследования в Java. Что такое суперклассы(родительские) и подклассы(дочерние)? Как наследование помогает переиспользовать код? Примеры реализации наследования.
## 51. Перегрузка метода в Java (overload). Переопределение метода в Java (override). В чем разница между перегрузкой и переопределением методов.
## 52. Наследование и отношение is-a. Как наследование реализует отношение «is-a»? Когда использование наследования может быть нецелесообразным? Примеры решений.
## 53. Ключевое слово super. Роль ключевого слова super в Java. Использование для вызова методов и конструкторов суперкласса. Примеры реализации.
## 54. Цепочка конструкторов. Понятие цепочки конструкторов. Как вызвать один конструктор из другого с использованием this() и super()? Примеры реализации.
## 55. Класс Object и его основные методы. Роль класса Object как суперкласса для всех классов в Java. Как метод toString() используется для представления объекта в виде строки? Примеры переопределения метода.
## 56. Полиморфизм. Понятие полиморфизма в Java. Как переменная супертипа может ссылаться на объект подтипа? Примеры применения полиморфизма для создания гибкого кода.

## 57. Интерфейсы в Java. Понятие интерфейсов как конструкций для определения общих операций. Основные элементы интерфейсов: константы и абстрактные методы. Примеры использования интерфейсов для создания обобщенных решений.
## 58. Интерфейсы в Java. Понятие интерфейсов как конструкций для определения общих операций. Особенности интерфейсов, добавленные в JAVA 8 версии. Дефолтные методы в интерфейсах.
## 59. Интерфейсы в Java. Особенности интерфейсов. Чем интерфейсы отличаются от классов? Как используются ключевые слова interface и implements? Примеры объявления и реализации интерфейсов.
## 60. Интерфейсы в Java 8 и 9. Новые возможности интерфейсов, такие как default и static методы (Java 8), а также private и private static методы (Java 9). Примеры реализации и применения.
## 61. Интерфейс Comparable. Как интерфейс Comparable используется для сравнения объектов? Реализация метода compareTo() и его роль в сортировке. Примеры работы с интерфейсом.
## 62. Интерфейс Comparable для классов стандартной библиотеки JAVA. Как реализован интерфейс Comparable в классах String, Integer и Date? Примеры сравнения объектов с помощью метода compareTo().
## 63. Интерфейс Comparable для пользовательских классов. Как реализовать интерфейс Comparable для пользовательских классов? Примеры сравнения объектов на основе пользовательских критериев.
## 64. Интерфейс Cloneable. Понятие клонирования объектов. Как интерфейс Cloneable позволяет клонировать объекты? Ограничения и примеры использования.
## 65. Метод clone(). Как метод clone(), определенный в классе Object, используется совместно с интерфейсом Cloneable? Примеры работы с клонируемыми объектами.
## 66. Интерфейсы и абстрактные классы. Основные различия между интерфейсами и абстрактными классами. 
## 67. Понятие абстрактных классов в Java. Что такое абстрактный класс, и как он используется для создания общего базового поведения? Чем отличается абстрактный класс от интерфейса? Примеры объявления и реализации абстрактного класса с абстрактными и конкретными методами.
## 68. Понятие абстрактных классов в Java. Объявление абстрактных методов. Что такое абстрактный метод, и какие правила нужно соблюдать при его объявлении? Как абстрактные методы помогают подклассам реализовать специфическое поведение? Примеры реализации абстрактных методов в наследуемых классах.
## 69. Понятие абстрактных классов в Java. Особенности работы с абстрактными классами. Почему абстрактные классы нельзя инстанцировать? Как использовать абстрактный класс как основу для других классов? Примеры создания иерархии классов с базовым абстрактным классом.
## 70. Ограничение множественного наследования в JAVA. Множественное наследование интерфейсов. Как классы наследуют методы от нескольких интерфейсов.
## 71. Интерфейсы в Java. Особенности интерфейсов. Интерфейсы и полиморфизм. Как интерфейсы способствуют реализации полиморфизма?

## 72. Обработка исключительных ситуаций в JAVA. Основные способы и подходы к обработке исключительных ситуаций в JAVA. Иерархия классов исключений в Java. Понятие и структура иерархии исключений. Чем отличаются классы Error, Exception и RuntimeException?
## 73. Создание и генерация исключений. Как создавать и генерировать исключения с помощью ключевого слова throw? Различия между throw и throws. Примеры создания пользовательских исключений.
## 74. Обработка исключений. Структура блока try-catch. Как обрабатывать исключения с использованием блоков try-catch? Примеры обработки нескольких исключений и упорядочения блоков catch. Роль объекта исключения (Exception e) в блоке catch.
## 75. Обработка исключений. Структура блока try-catch. Блок finally и его использование. Основные причины использования. Примеры использования.
## 76. Обработка исключений. Пропагирование исключений. Как исключения передаются вверх по стеку вызовов? Примеры использования ключевого слова throws в сигнатуре методов.
## 77. Обработка исключений. Проверяемые и непроверяемые исключения. Какие исключения считаются проверяемыми (checked), а какие - непроверяемыми (unchecked)? Примеры работы с ними. Исключения в популярных фреймворках. Почему большинство исключений в современных фреймворках являются непроверяемыми?
## 78. Обработка исключений. Использование try-with-resources. Как она упрощает управление ресурсами? Примеры работы.
## 79. Обработка исключитеьных ситуаций в JAVA. Роль JVM в обработке исключений. Как JVM управляет исключениями, если они не были обработаны? Примеры поведения при неперехваченных исключениях.
## 80. Перечисления (enums) в Java. Что такое перечисления и как они используются для создания фиксированных наборов значений? Характеристики перечислений. Перечисления и типобезопасность. Примеры их применения.
## 81. GUI в Java. Что такое GUI (графический пользовательский интерфейс)? Основные пакеты для работы с GUI в Java: AWT и Swing.
## 82. GUI в Java. Структура GUI в JAVA при реализации через Swing и AWT. Компоненты GUI. Какие элементы составляют графический интерфейс? Примеры кнопок, текстовых полей и других компонентов.
## 83. AWT (Abstract Window Toolkit). Что такое AWT и как он используется для создания GUI? Примеры простых интерфейсов с использованием AWT.
## 84. Swing в Java. Как Swing расширяет возможности AWT? Примеры создания интерфейсов с использованием Swing. Паттерн MVC в Swing. Как Swing реализует модель MVC (Model-View-Controller)? Примеры разделения логики, представления и управления в интерфейсе.
## 85. Структура GUI в Java. Основные компоненты GUI в Swing: контейнеры (JFrame, JPanel, JDialog), компоненты (JButton, JLabel, JTextField) и менеджеры компоновки. 
## 86. Класс JFrame. Что такое окно JFrame, и как использовать его для создания графического интерфейса? Примеры добавления элементов через метод getContentPane().
## 87. Класс JPanel. Как панель JPanel используется для группировки и управления компонентами? Примеры изменения менеджера компоновки с помощью метода setLayout().
## 88. Менеджеры компоновки в Java. Роль менеджеров компоновки в управлении размещением компонентов. Примеры использования менеджеров FlowLayout, BorderLayout, GridLayout.
## 89. Менеджер FlowLayout. Как работает FlowLayout? Примеры настройки выравнивания и промежутков между компонентами.
## 90. Менеджеры компоновки в Java. Роль менеджеров компоновки в управлении размещением компонентов. Примеры использования менеджеров FlowLayout, BorderLayout, GridLayout.
## 91. Менеджер FlowLayout. Как работает FlowLayout? Примеры настройки выравнивания и промежутков между компонентами.
## 92. Менеджер BorderLayout. Как BorderLayout делит контейнер на регионы (NORTH, SOUTH, EAST, WEST, CENTER)? Примеры создания интерфейсов с четкой организацией областей.
## 93. Менеджер GridLayout. Как компоненты размещаются в сетке с использованием GridLayout? Примеры создания таблиц или форм.
## 94. Менеджер BoxLayout. Как компоненты размещаются по горизонтали или вертикали с помощью BoxLayout? Примеры последовательного расположения элементов.
## 95. Границы в Swing. Как использовать границы для улучшения внешнего вида интерфейса? Примеры применения границ.
## 96. GUI и сбытийная модель в Java. Что такое событийная модель, и как она используется для взаимодействия компонентов через события? Основные элементы событийной модели.
## 97. Обработка событий в Java. Как источник события, слушатель и обработчик взаимодействуют в событийной модели? Примеры добавления слушателей событий. Модель делегирования событий. Как работает модель делегирования событий? 
## 98. Обработка событий при реализации GUI в JAVA. Классы событий пакета java.awt.event. Какие классы событий предоставляет пакет java.awt.event? Примеры обработки событий мыши и клавиатуры.
## 99. Обработка событий мыши в JAVA. Как использовать интерфейсы MouseListener и MouseMotionListener для обработки событий мыши? Примеры обработки нажатий и перемещений.
## 100. Обработка событий клавиатуры в JAVA. Как обрабатывать события клавиатуры с использованием KeyListener? Примеры регистрации слушателей клавиатурных событий.
## 101. Обобщённое программирование в Java. Понятие обобщённого программирования и его роль в упрощении создания алгоритмов для работы с различными типами данных. История разваития в JAVA. Примеры проектирования универсальных структур данных и алгоритмов.
## 102. Generics в Java. Реализация обобщенного программирования через Generics. Основные синтаксические конструкции: параметры типов, обобщенные классы и методы. Примеры работы с параметризованными классами и методами. Примущества и недостатки Generics.
## 103. Коллекции и Generics в Java. Как использование Generics повысило типобезопасность коллекций, таких как ArrayList, HashMap и HashSet? Примеры создания и обработки коллекций с обобщениями.
## 104. Параметризованные методы. Понятие параметризованных методов в Java. Как они позволяют работать с любыми типами данных? Примеры реализации методов с обобщенными параметрами и их вызова.
## 105. Generics в Java. Типовые ограничения в Generics. Как задать ограничения на параметры типов с помощью ключевых слов extends и super? Примеры их использования для обеспечения гибкости и безопасности обобщений.
## 106. Обобщенные интерфейсы. Использование Generics для создания универсальных интерфейсов. Примеры реализации обобщенных интерфейсов и их применения в реальных задачах.
## 107. Generics в Java. Подстановочные знаки (Wildcards). Как использовать ?, <? extends T> и <? super T> для работы с коллекциями? Примеры их применения.
## 108. Generics в Java. Стирание типов (Type Erasure). Как информация о Generics удаляется во время компиляции? Примеры преобразования Generics в сырой тип.
## 109. Коллекции в Java. Понятие коллекций как структур данных для хранения объектов. Основные интерфейсы и классы в Java Collections Framework (JCF). Примеры использования коллекций для хранения и обработки данных.
## 110. Иерархия коллекций. Структура иерархии коллекций в Java. Основные интерфейсы (Collection, List, Set, Map) и их ключевые особенности. Примеры реализации различных типов коллекций.
## 111. LinkedList в Java. Особенности класса LinkedList как реализации интерфейса List. Преимущества использования. 
## 112. Коллекции в Java. Понятие коллекций как структур данных для хранения объектов. Основные цели использования коллекций. Роль Iterable в Java Collections Framework. 
## 113. Коллекции в Java. Реализации List - ArrayList. Особенности функционирования ArrayList. Пример использования ArrayList.
## 114. Коллекции в Java. Создание Generic Collection в Java. Преимущства данного подхода. Примеры. 
## 115. Коллекции и Generics. Использование Generics для типобезопасности в коллекциях. Примеры создания типизированных списков и множеств.
## 116. ArrayList в Java. Понятие ArrayList как реализации интерфейса List. Основные методы (add, get, remove) для работы со списками. Примеры добавления, удаления и доступа к элементам.
## 117. Задача на выполнение


