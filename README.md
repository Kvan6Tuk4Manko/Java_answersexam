## 1. Введение в Java. Основные характеристики языка, сферы применения, история создания. Экосистема языка JAVA. JDK, JRE, JVM. 
- Простой - построен на основе языка C++, но значительно упрощен
- Объектно-ориентированный - Java с самого начала проектировался как объектно-ориентированный
- Распределенный - разработан для упрощения распределенных вычислений
- Интерпретируемый - для запуска необходим интерпретатор
- Надежный - Java-компиляторы могут обнаружить множество проблем
- Безопасный - несколько механизмов безопасности
- Кросс-платформенный - «Один раз напишите, везде запустите»
- Высокопроизводительный - достаточная скорость для интерактивных приложений, где центральный процессор простаивает
- Многопоточный - многопоточное программирование плавно интегрировано в Java
- Динамичный - новые функциональные возможности Java могут прозрачно встраиваться
---
- Java — это мощный и универсальный язык программирования
для разработки программного обеспечения, работающего на
мобильных устройствах, встраиваемых системах, настольных
компьютерах, серверах и т.д.

- Важные системы: банковские терминалы, системы обработки
транзакций, сервисы координации перелетов и другие.
---
- Java Development Kit (JDK) – это программный комплект, который предоставляет всё необходимое для разработки и компиляции Java-приложений.
- Java Runtime Environment (JRE) – это окружение, необходимое для выполнения Java-программ.
- Java Virtual Machine (JVM) – это центральный компонент платформы Java, который обеспечивает независимость кода от конкретной операционной системы и аппаратной архитектуры. JVM является частью JRE.

## 2. Основные платформы Java. Java SE, Java EE, Java ME, их особенности и области применения. 
- Java Card - создание приложений для смарт-карт и других устройств с ограниченными вычислительными ресурсами.
- Java Standard Edition (Java SE)-разработка настольных и серверных приложений. Она предоставляет стандартные библиотеки и API для создания полнофункциональных приложений.
- Java Micro Edition (Java ME) - создание приложений, работающих на мобильных устройствах, встроенных системах и т.д.
- Java Enterprise Edition (Java EE) - создания масштабируемых, надёжных и управляемых корпоративных приложений

## 3. Виртуальные машины и их роль в JAVA. Архитектура JVM. Основные компоненты: Class Loader, Execution Engine, Garbage Collector.
- В Java можно использовать различные реализации виртуальных машин, хотя наиболее широко распространенной и часто используемой является стандартная JVM (Java Virtual Machine), поставляемая с Oracle JDK или OpenJDK.
- OpenJ9
- GraalVM
- Zulu JVM
- Kotlin/Native(не является полной заменой JVM)
- Роль JVM: Обеспечить переносимость кода на различные платформы.
---
- Class Loader - модуль, который отвечает за загрузку классов в память. Class Loader выполняет динамическую загрузку классов во время выполнения программы и позволяет JVM загружать классы из различных источников, таких как файловая система или сеть.
- Execution Engine -модуль, который отвечает за выполнение байт-кода. Execution Engine может использовать интерпретацию байт-кода или Just-In-Time (JIT) компиляцию для преобразования байт-кода в машинный код и его выполнения.
- Garbage Collector (GC) - механизм автоматического управления памятью, который освобождает память, занимаемую объектами, которые больше не используются программой. GC помогает избежать утечек памяти и обеспечивает стабильную работу приложений.

## 4. Компиляция Java-программ. Различия между JIT (Just-in-Time) и AOT (Ahead-of-Time) компиляцией. Преимущества и недостатки. 
- Компиляция Ahead-of-Time (AOT) и компиляция Just-in-Time (JIT) в Java представляют собой два разных метода преобразования байт-кода Java в машинный код, но применяются они на разных этапах жизненного цикла программы и имеют разные цели.
- JIT-компиляция (Just-in-Time) — это процесс компиляции байт-кода Java в машинный код непосредственно во время выполнения программы. Когда программа запускается, байт-код интерпретируется JVM, и по мере необходимости определенные участки кода компилируются в машинный код "на лету" (just-in-time), чтобы повысить производительность.
- AOT-компиляция — это процесс компиляции байт-кода Java в машинный код до запуска программы. В отличие от JIT, который компилирует код "на лету", AOT-компиляция производится заранее, например, во время сборки или установки приложения.

## 5. Модель памяти в Java. Основные области памяти JVM: куча (Heap) и стек (Stack), их назначение и различия. Как распределяются объекты и примитивные данные в этих областях? Что такое Young Generation, Old Generation и Metaspace? Как работа сборщика мусора влияет на управление памятью?
- Java предоставляет автоматическое управление памятью
---
- Heap (Куча) - это область памяти, где хранятся все объекты и массивы, создаваемые в Java-программе с использованием ключевого слова new. Управление памятью в куче осуществляется автоматически с помощью сборщика мусора.
- Stack (Стек) - используется для хранения примитивных типов данных (например, int, float, char) и ссылок на объекты в куче. Каждый поток имеет свой собственный стек, который управляет вызовами методов, их параметрами, локальными переменными и возвращаемыми значениями. В отличие от кучи, память в стеке выделяется и освобождается автоматически, при вызове и завершении методов.
---
- Young Generation (Молодое поколение)
- Old Generation (Старое поколение)
- Permanent Generation (Metaspace в Java 8 и выше)
- PermGen (Permanent Generation) — это специальное место в куче, отделенное от основной памяти. Здесь виртуальная машина хранит метаданные загруженных классов. Полностью удалена в JDK 8.
- Metaspace – новая область памяти, заменившая устаревшую PermGen. Основное их отличие заключается в способе распределения памяти. Metaspace выделяется из памяти нативной ОС, а не из памяти JVM. Это улучшило масштабируемость.
---
- Освобождение памяти происходит автоматически с помощью встроенного сборщика мусора.
- Сборщик мусора (garbage collector) автоматически проверяет область памяти, где живут объекты Java – Java Heap (куча) – и уничтожает их, если они стали не нужны программе.
- Алгоритм работы сборщика мусора зависит от конкретной платформы – а значит, конкретной JVM

## 6. Основные парадигмы программирования в Java. Объектно-ориентированное, функциональное, многопоточное программирование.
О парадигмах программирования в JAVA
- Java поддерживает несколько парадигм программирования, что делает её мощным и универсальным языком.
- Императивное программирование - Java поддерживает императивный стиль
- Обобщенное программирование (Generic Programming) - Java поддерживает обобщённое программирование через использование дженериков (generics).
- Реактивное программирование - через сторонние библиотеки, такие как Project Reactor или RxJava.
---
- Объектно-ориентированное программирование (ООП) - основная парадигма, на которой построена Java.
- Функциональное программирование - начиная с версии Java 8, язык добавил поддержку функционального программирования.
- Многопоточное программирование - Java предлагает встроенные средства для разработки многопоточных программ, что является частью парадигмы конкурентного программирования.

## 7. Виртуальные машины и их роль в JAVA. Особенности стандартной HotSpot JVM. GraalVM и другие сторонние виртуальные машины для Java. Основные преимущества и возможности сторонних виртуальных машин.
- В Java можно использовать различные реализации виртуальных машин, хотя наиболее широко распространенной и часто используемой является стандартная JVM (Java Virtual Machine), поставляемая с Oracle JDK или OpenJDK.
- OpenJ9
- GraalVM
- Zulu JVM
- Kotlin/Native(не является полной заменой JVM)
- Роль JVM: Обеспечить переносимость кода на различные платформы.
---
JIT-компиляция(HotSpot JIT)
- JIT-компиляция (Just-in-Time) — это процесс компиляции байт-кода Java в машинный код непосредственно во время выполнения программы. Когда программа запускается, байт-код интерпретируется JVM, и по мере необходимости определенные участки кода компилируются в машинный код "на лету" (just-in-time), чтобы повысить производительность.
- На текущий момент в JVM многоуровневая компиляция (tiered compilation). Существует не один, а два компилятора: C1 и C2.
---
GraalVM
- Это многофункциональная виртуальная машина, основанная на HotSpot/OpenJDK и написанная на Java и разработанная для запуска приложений, написанных на разных языках программирования, с высокой производительностью и возможностью выполнения кода на различных платформах.
---
Основные преимущества и возможности сторонних виртуальных машин
- Высокая производительность: Многие сторонние JVM предлагают более высокую производительность по сравнению с HotSpot, особенно в специфических сценариях использования.
- Новые возможности: Сторонние JVM могут предоставлять новые функции и возможности, которые отсутствуют в HotSpot.
- Специализация: Некоторые JVM специализируются на определенных типах приложений, таких как серверные приложения или приложения с низкой задержкой.
- Инновации: Сторонние JVM часто являются площадкой для экспериментов и внедрения новых технологий
## 8. Компиляция и запуск проекта на Java. Обеспечение переносимости кода на различные платформы. Понятие промежуточного байт-кода и его роль в переносимости программ. Чем отличаются методы компиляции JIT (Just-In-Time) и AOT (Ahead-of-Time), и как они влияют на производительность и переносимость?
- Java является языком программирования, который сочетает в себе как компиляцию, так и интерпретацию.
---
- Компиляция Ahead-of-Time (AOT) и компиляция Just-in-Time (JIT) в Java представляют собой два разных метода преобразования байт-кода Java в машинный код, но применяются они на разных этапах жизненного цикла программы и имеют разные цели.

## 9. Современный инструментарий разработчика Java. Популярные IDE и их возможностей для написания, отладки и сборки кода. Основные системы сборки и их роль в управлении проектами на JAVA. Контроль версий с использованием Git и интеграция с платформами хостинга ИТ-проектов. Использование Docker и Kubernetes для контейнеризации и оркестрации приложений. Инструменты CI/CD  для автоматизации сборки, тестирования и деплоя JAVA приложений.
- Среда разработки (IDE) — это ключевой инструмент Java-разработчика, который предоставляет удобный интерфейс для написания, отладки и сборки кода. (IntelliJ IDEA, Eclipse, Apache NetBeans)
- Системы сборки автоматизируют процесс компиляции, тестирования и упаковки приложений, а также управления зависимостями. (Maven, Gradle, Ant)
- Контроль версий (Git, GitHub, GitLab, Bitbucket.)
- Инструменты для тестирования. Java предлагает широкий спектр инструментов для написания и автоматизации тестов (JUnit, TestNG, Mockito)
- Инструменты для непрерывной интеграции и деплоя (CI/CD). CI/CD инструменты помогают автоматизировать процесс сборки, тестирования и деплоя приложений. (Jenkins, GitLab CI, CircleCI)
- Контейнеризация и оркестрация помогают разрабатывать, тестировать и деплоить Javaприложения в изолированных средах. (Docker, Kubernetes)

## 10. Современные фреймворки для разработки на Java. Особенности Spring Framework. Основные возможности Hibernate. Основные причины использования данных фреймворков при разработке на JAVA.
Фреймворки JAVA
- Spring Framework - один из самых популярных и мощных фреймворков в экосистеме Java. Разработан в 2003 году для упрощения разработки корпоративных приложений на Java.
---
Hibernate выступает посредником между кодом и базой данных, позволяя легко настраивать преобразование объектов вручную
1. ускоряет написание кода;
2. создаёт удобную модель отображения уже существующей базы внутри кода;
3. позволяет задать стандарт переноса информации из кода в БД

## 11. Объектная модель Java. Основные принципы объектной модели в Java: классы, объекты, интерфейсы, наследование и инкапсуляция. Класс Object и методы, которые он предоставляет.
- Java объектный язык следовательно он оперирует объектами
- Все сущности в Java являются объектами, классами либо интерфейсами.
- На вершине иерархии класс Object, у которого много методов: String toString(), boolean equals(Object o), Object clone(), int hashCode()
- Все объекты, которые вы будете создавать являются потомками класса Object
- Вы можете переопределить методы класса Object в с воем классе пользовательском классе
- Строгая реализация инкапсуляции.
- Реализовано одиночное наследование от класса и множественное от интерфейсов.

## 12. Пакеты в Java. Основное предназначение. Структура, организация, использование в программировании (импорт пакетов).
- Пакет (package) — это именованное пространство, которое группирует схожие по функциональности классы и интерфейсы.
- Помогают структурировать код, избегать конфликтов имен и контролировать видимость классов и методов.
- В состав пакетов входят:
- классы;
- интерфейсы;
- вложенные пакеты.
---
- Структура пакетов. Имя пакета обычно соответствует структуре каталогов в файловой системе. Например, для пакета com.example.myapp, исходный файл MyClass.java должен располагаться в каталоге com/example/myapp.
- Пакеты могут быть вложенными, что позволяет создавать иерархию пакетов. Например:
- com.example: базовый пакет.
- com.example.myapp: подпакет внутри com.example.
- com.example.myapp.utils: вложенный пакет внутри com.example.myapp.
---
Импорт пакетов
- ключевое слово import
- можно импортировать все классы иинтерфейсы из пакета, используя
символ звёздочки *. Предпочтительно
использовать явный импорт конкретных
классов.
- ВАЖНО! Пакет java.lang автоматически
импортируется в каждую программу
Java по умолчанию. Это значит, что вы
можете использовать классы из java.lang
без явного импорта.

## 13. Синтаксис и лексика Java. Основные элементы лексики языка: ключевые слова, идентификаторы, литералы, комментарии, операторы и разделители. Правила именования идентификаторов. Соглашения по оформлению кода.
Лексика — это совокупность
правил, определяющих допустимые
элементы программы на уровне
символов, слов и простых
выражений.
- Ключевые слова
- Идентификаторы
- Литералы
- Комментарии
- Операторы
- Разделители

Синтаксис Java — это набор правил,
определяющих правильное
построение программ на языке
Java.
- Структура программы
- Объявление классов и методов
- Переменные и типы данных
- Циклы
- Методы
---
- Ключевые слова в Java — это зарезервированные слова, которые имеют
специальное значение и используются для определения структуры и
поведения программы.
- Нельзя использовать в качестве идентификаторов (например, имен
переменных, методов, классов и т.д.)
---
- Идентификаторы для переменных
- Идентификаторы для методов
- Идентификаторы для классов и
интерфейсов
- Идентификаторы для пакетов
- Идентификаторы для констант
--- 
Соглашения по оформлению кода Java
(Java Code Conventions) - это набор рекомендаций и стандартов по
написанию кода на языке Java,
разработанный компанией Sun
Microsystems.

## 14. Типы данных в Java. Примитивные типы данных, объявление и присваивание переменных. Отличия примитивных типов данных от ссылочных.
Примитивные(базовые)
- Вещественные
- Целочисленные
- Логические

Ссылочные(объектные)
- Различные типы данных и интерфейсов
- Переменная ссылочного
- null

Целочисленные типы данных:
- byte – 8-битовое целое число со знаком(-128 до 127),
- short – 16-битовое целое число со знаком(от -32,768 до 32,767),
- int – 32-битовое целое число со знаком(-2,147,483,648 до 2,147,483,647),
- long – 64-битовое целое число со знаком(-9,223,372,036,854,775,808 до
9,223,372,036,854,775,807)



## 15. Типы данных в Java. Ссылочные типы данных, объявление и присваивание переменных. Отличия ссылочных типов данных от примитивных. Роль классов-оберток (Wrapper Classes) для работы с примитивами.
Примитивные(базовые)
- Вещественные
- Целочисленные
- Логические

Ссылочные(объектные)
- Различные типы данных и интерфейсов
- Переменная ссылочного
- null

Ссылочные(объектные) типы данных
- В Java все объектные типы данных являются ссылочными типами. Это
означает, что переменные объектных типов всегда хранят ссылки на
объекты, а не сами объекты.

## 16. Константы в Java. Понятие констант и их объявление с использованием ключевого слова final. Основные правила и соглашения по именованию констант. Примеры создания констант для примитивных типов данных и строк. Как константы помогают обеспечить неизменность данных и улучшают читаемость кода?
Модификатор final
- Когда переменная объявляется как final, она может быть 
инициализирована только один раз. После этого ее 
значение не может быть изменено.
- Переменные могут быть локальными (в методах) или 
полями класса
```Java
final int MAX_VALUE = 100
```

## 17. Ключевое слово var в Java. Особенности использования var для объявления локальных переменных. Как происходит неявное выведение типа переменной компилятором? Ограничения на использование var: недопустимость для полей класса, параметров методов и возвращаемых типов.
- Улучшение читаемости кода, упрощение написания кода
- Неявное выведение типов или объявления переменных без явного указания 
типа 
- var используется только для локальных переменных, объявленных внутри 
методов, блоков или лямбда-выражений. Не может быть использовано для 
полей класса, параметров методов или возвращаемых типов.
```Java
var message = "Hello, world!"
```
## 18. Соглашения по оформлению кода Java. Java Code Conventions и её значение для совместной работы.
- Это набор рекомендаций и стандартов по
написанию кода на языке Java,
разработанный компанией Sun
Microsystems.
- Следование этим стандартам также
упрощает процесс чтения и понимания
кода другими разработчиками.
---
Инстанцирование
 происходит, когда 
используется ключевое 
слово new для создания 
объекта в памяти


## 19. Класс и экземпляры класса. Что такое класс в Java и как происходит создание объектов (инстанцирование) с использованием ключевого слова new? Примеры создания и использования экземпляров класса.
- Класс — это шаблон 
или модель (blueprint), 
которая определяет 
структуру и поведение 
объектов
- Экземпляр объекта —
это конкретная 
реализация (instance) 
класса, созданная в 
памяти программы
```Java
Car car1 = new Car("Toyota", 2020)
```

## 20. Записи (Records) в Java. Какие возможности они предоставляют и в чем их отличие от обычных классов? Примеры использования записей.
Развивает идею pattern matching
- Предназначены для создания неизменяемых 
(immutable) классов данных, которые автоматически 
предоставляют стандартные реализации таких 
методов, как equals(), hashCode(), toString() и 
автоматическую инициализацию полей.
- Цель — сократить количество шаблонного кода
```Java
public record OrderMessage(Long orderId, String product, int quantity) {
}
```

## 21. Запечатанные (Sealed) классы. Как они ограничивают наследование и для чего используются?
- Запечатанный (sealed) класс позволяет 
ограничивать или выбирать подклассы. Класс не 
может расширять закрытый класс, если его нет в 
списке разрешенных дочерних классов 
родительского класса
```Java
public sealed class Shape permits Circle, Rectangle, Triangle {
// Общие свойства и методы для всех фигур
}
```
---
- Запечатанный (sealed) 
класс позволяет 
ограничивать или 
выбирать подклассы. Класс 
не может расширять 
закрытый класс, если его 
нет в списке разрешенных 
дочерних классов 
родительского класса.



## 22. Инкапсуляция в Java. Понятие инкапсуляции как механизма защиты данных и управления доступом к ним. Реализация инкапсуляции с использованием модификаторов доступа (private, protected, public, package-private). Роль геттеров и сеттеров в обеспечении контроля за изменением данных объекта. Примеры нарушения инкапсуляции и способы предотвращения этих ошибок.
- Цель инкапсуляции —
защитить данные и 
внутренние детали 
реализации объектов от 
прямого доступа и 
изменений извне
---
Public (публичный доступ)
- Поля или методы, объявленные как public, доступны из любого 
места в программе — как внутри одного класса или пакета, так и 
за его пределами. Это наиболее открытый уровень доступа.

Private (приватный доступ)
- Поля или методы, объявленные как private, доступны только 
внутри класса, в котором они объявлены. Это наиболее строгий 
уровень доступа

Protected (защищенный доступ)
- Поля или методы, 
объявленные как 
protected, доступны 
внутри одного и того же 
пакета, а также в 
подклассах, даже если 
эти подклассы находятся 
в других пакетах

Модификатор по умолчанию
- Если модификатор доступа не указан, доступ считается 
package-private (доступ внутри пакета). Это означает, что 
поля и методы доступны только для классов, находящихся в 
том же пакете.
---
Стандартные методы класса Геттеры и Cеттеры
- Геттеры и сеттеры — это стандартные методы, которые 
обеспечивают доступ к полям (свойствам) объекта класса.
- Геттеры — это методы, предназначенные для получения значения приватного поля 
класса. Обычно они объявляются как public и возвращают значение 
соответствующего поля.
- Сеттеры — это методы, предназначенные для изменения значения приватного поля 
класса. Обычно объявляются как public и позволяют изменить значение поля с 
помощью переданного аргумента.

## 23. Модификаторы доступа. Какие уровни доступа существуют в Java? Как модификаторы доступа используются для контроля видимости классов, полей и методов?
Public (публичный доступ)
- Поля или методы, объявленные как public, доступны из любого 
места в программе — как внутри одного класса или пакета, так и 
за его пределами. Это наиболее открытый уровень доступа.

Private (приватный доступ)
- Поля или методы, объявленные как private, доступны только 
внутри класса, в котором они объявлены. Это наиболее строгий 
уровень доступа

Protected (защищенный доступ)
- Поля или методы, 
объявленные как 
protected, доступны 
внутри одного и того же 
пакета, а также в 
подклассах, даже если 
эти подклассы находятся 
в других пакетах

Модификатор по умолчанию
- Если модификатор доступа не указан, доступ считается 
package-private (доступ внутри пакета). Это означает, что 
поля и методы доступны только для классов, находящихся в 
том же пакете.

## 24. Модификатор final. Применение final к переменным, методам и классам. Как он предотвращает изменения данных, поведение методов и наследование? 
Модификатор final
- Когда переменная объявляется как final, она может быть 
инициализирована только один раз. После этого ее 
значение не может быть изменено.
- Переменные могут быть локальными (в методах) или 
полями класса
- Роль в управлении неизменяемостью данных, безопасности 
многопоточных программ и предотвращении нежелательных 
изменений
- Может применяться к переменным, методам и классам


final для переменных
- Когда переменная объявляется как final, она может быть 
инициализирована только один раз. После этого ее 
значение не может быть изменено.
- Переменные могут быть локальными (в методах) или 
полями класса.

final для методов
- Когда метод объявляется как 
final, он не может быть 
переопределен в подклассе.
- Полезно, чтобы предотвратить 
изменение поведения метода в 
наследуемых классах.

final для классов
- Когда класс объявляется как final, 
его нельзя наследовать. 

P.S. у составителей нет идей для вопросов, поэтому они ставят одни и те же.

## 25. Конструкторы в Java. Понятие конструктора и его роль в создании объектов. Различия между конструктором и методом. Типы конструкторов. Как реализовать перегрузку конструкторов? 
- Конструкторы в Java — это 
специальные методы, которые 
вызываются при создании нового 
объекта класса. Они инициализируют 
поля объекта и 
могут выполнять 
другую необходимую логику.
---
Конструктор по умолчанию
- Если в классе не определено ни 
одного конструктора, компилятор 
автоматически создаёт конструктор 
по умолчанию, который не 
принимает никаких параметров и 
просто инициализирует поля объекта 
значениями по умолчанию 
(например, 0, null или false)

Пользовательский (явный) конструктор
- Это конструктор, который 
разработчик явно определяет в классе 
для инициализации объекта.
 
Перегруженные конструкторы
- Конструкторы могут быть 
перегружены, что позволяет 
создавать несколько версий 
конструктора с разным 
количеством или типами 
параметров.

Приватные конструкторы
- Конструктор может быть 
объявлен как private. 


Дорогой дневник, мне не описать ту боль, которую я испытал...

## 26. Конструкторы в Java. Понятие конструктора и его роль в создании объектов. Использование ключевого слова this для вызова одного конструктора из другого. Особенности работы конструкторов в наследовании, вызов конструктора родительского класса через super.
- Конструкторы в Java — это 
специальные методы, которые 
вызываются при создании нового 
объекта класса. Они инициализируют 
поля объекта и 
могут выполнять 
другую необходимую логику.
---
Ключевое слово this
- this представляет собой ссылку на текущий 
объект, для которого вызван метод или 
выполняется блок кода
---
Ключевое слово super
- Ключевое слово super ссылается на суперкласс, и его можно 
использовать для вызова методов и конструкторов 
суперкласса

## 27. Блоки инициализации. Виды блоков инициализации: статические и нестатические. Их роль в подготовке объектов и классов. Примеры использования блоков для сокращения повторяющегося кода.
- В Java существуют блоки 
инициализации, которые можно 
использовать для инициализации 
переменных или выполнения 
кода при создании объекта.
- Это участки кода, которые 
используются для выполнения 
логики инициализации объекта 
или класса перед вызовом 
конструктора или при загрузке 
класса. 
---
Обычные (нестатические) блоки инициализации
- Обычные блоки инициализации 
используются для выполнения 
кода, который будет 
выполняться каждый раз при 
создании нового экземпляра 
класса.
- Код в обычном блоке 
инициализации выполняется 
перед вызовом конструктора, но 
после инициализации полей

Статические блоки инициализации
- Используются для 
инициализации статических 
полей класса и выполняются 
один раз при загрузке класса в 
память (когда класс используется 
в программе впервые).
- Это происходит до создания 
каких-либо объектов этого 
класса

## 28. Статические блоки инициализации. Примеры и использование статических блоков для выполнения кода при загрузке класса. Их роль в инициализации общих данных.
Статические блоки инициализации
- Используются для 
инициализации статических 
полей класса и выполняются 
один раз при загрузке класса в 
память (когда класс используется 
в программе впервые).
- Это происходит до создания 
каких-либо объектов этого 
класса
---
- Статический блок инициализации 
выполняется один раз при первом обращении 
к классу Config, и все статические поля класса 
инициализируются значениями.
- Гарантирует, что значения будут установлены 
до любого обращения к классу Config, и они 
будут инициализированы только один раз.

## 29. Модификатор static. Особенности использования static для полей, методов и блоков. Различия между статическими и нестатическими членами класса. Примеры применения для создания общих ресурсов.
Модификатор static
- Позволяет создавать поля, 
методы и блоки, которые 
принадлежат классу и не 
зависят от его экземпляров.

Модификатор static может быть 
применен к:
- Переменным (полям класса)
- Методам
- Блокам инициализации
- Вложенным классам

## 30. Ключевое слово this. Использование this для доступа к полям и методам объекта, вызова других конструкторов и передачи текущего объекта. Примеры решения конфликтов имен с помощью this.
this представляет собой ссылку на текущий 
объект, для которого вызван метод или 
выполняется блок кода.

Использование this в Java:
- Доступ к полям объекта
- Вызов методов объекта
- Вызов конструктора с помощью this()
- Передача текущего объекта в качестве 
аргумента
---
Доступ к полям объекта
- Когда имена параметров метода или 
конструктора совпадают с именами 
полей объекта, this помогает отличить 
поле объекта от локальной 
переменной

## 31. Концепция неизменяемых классов. Что делает класс неизменяемым? Использование final для предотвращения изменений. Примеры создания неизменяемых объектов.
- Концепция неизменяемых классов (immutable classes) в программировании подразумевает, что после создания объекта его состояние (значения полей) не может быть изменено. Это означает, что любые изменения, которые должны быть применены к объекту, требуют создания нового экземпляра этого объекта с обновлёнными значениями.
---
Что делает класс неизменяемым?

1. Финальные поля: Все поля класса объявляются как final, что означает, что они могут быть инициализированы только один раз, обычно в конструкторе. После этого значения этих полей нельзя изменить.

2. Отсутствие методов изменения: Необходимо избегать предоставления методов, которые изменяют состояние объекта (например, сеттеров). Вместо этого можно предоставлять методы, которые возвращают новые экземпляры объекта с изменёнными значениями.

3. Конструктор: Все поля должны инициализироваться в конструкторе, и после этого не должно быть возможности их изменить.

4. Неизменяемые коллекции: Если класс содержит ссылки на изменяемые объекты (например, массивы или коллекции), то необходимо создавать их копии или использовать неизменяемые версии этих коллекций.
   
## 32. Создание объектов. Отличие фабричных методов от стандартного создания объектов с использованием new. Примеры использования фабричных методов.
Фабричный метод — это метод, который создает и возвращает объект. Он может быть статическим или экземплярным методом и может использоваться для инкапсуляции логики создания объектов. Фабричные методы могут быть полезны в следующих случаях:

1. Скрытие логики создания: Они могут скрывать детали реализации, позволяя изменять способ создания объектов без изменения кода, который их использует.

2. Упрощение кода: Фабричные методы могут возвращать объекты разных подклассов, основываясь на параметрах, переданных в метод.

3. Управление жизненным циклом объектов: Они могут включать логику для управления кэшированием, пуллингом объектов и т.д.

---
1. Инкапсуляция логики создания: Фабричные методы позволяют скрыть детали создания объекта от клиента. При использовании new клиент должен знать о конкретном классе и его конструкторах.

2. Гибкость: Фабричные методы могут возвращать объекты разных классов, основываясь на переданных параметрах. Это позволяет легко добавлять новые типы объектов без изменения клиентского кода.

3. Управление жизненным циклом: Фабричные методы могут включать логику для управления созданием и уничтожением объектов (например, кэширование), что невозможно при прямом использовании new.

4. Упрощение тестирования: Использование фабричных методов может облегчить тестирование, так как можно подменять реализацию фабрики для создания мок-объектов.

## 33. Рефлексия в Java. Возможности рефлексии для создания объектов и вызова методов во время выполнения. Примеры использования рефлексии для создания объектов.
- Рефлексия — это механизм в
Java, который позволяет
динамически создавать объекты
и вызывать методы во время
выполнения программы.
---
Возможности рефлексии и карьерный рост
1. Получение информации о классах: Можно получить информацию о классах, интерфейсах, методах, полях и конструкторах.
2. Создание объектов: Можно создавать экземпляры классов динамически.
3. Вызов методов: Можно вызывать методы объектов, даже если они были скрыты или объявлены как приватные.
4. Доступ к полям: Можно читать и изменять значения полей, даже если они были объявлены как приватные.

``` Java
import java.lang.reflect.Constructor;

class MyClass {
    private String message;

    public MyClass(String message) {
        this.message = message;
    }

    @Override
    public String toString() {
        return "MyClass{" +
                "message='" + message + '\'' +
                '}';
    }
}

public class ReflectionExample {
    public static void main(String[] args) {
        try {
            // Получаем класс MyClass
            Class<?> clazz = Class.forName("MyClass");

            // Получаем конструктор с одним параметром типа String
            Constructor<?> constructor = clazz.getConstructor(String.class);

            // Создаем новый объект с помощью конструктора
            Object obj = constructor.newInstance("Hello, Reflection!");

            // Выводим результат
            System.out.println(obj);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
## 34. Жизненный цикл объектов в JAVA. Роль сборщика мусора в управлении памятью. Примеры оптимизации работы объектов в Java.
- Объекты в Java создаются в
куче (heap) с использованием
ключевого слова new, и их
жизнь продолжается до тех пор,
пока на объект есть хотя бы
одна активная ссылка.
- Когда на объект больше нет
ссылок, его удаляет сборщик
мусора (Garbage Collector).

``` Java
Car car = new Car("Toyota", 2020);
car = null;
```
## 35. Инициализация переменных в JAVA. Способы инициализации переменных: по умолчанию, в конструкторах, через блоки инициализации. Примеры применения.
- Инициализация в Java - это процесс присвоения
начальных значений
переменным или полям класса,
прежде чем они будут
использованы в программе.
---
Инициализация по умолчанию
- Когда в Java создается объект, поля
класса автоматически
инициализируются значениями по
умолчанию, если разработчик явно не
присвоил им значения.

Инициализация в конструкторах
- Конструкторы используются для инициализации объектов при их создании. Конструкторы могут принимать параметры и использовать их для установки значений полей.


Инициализация с помощью блоков инициализации
- В Java существуют блоки
инициализации, которые можно
использовать для инициализации
переменных или выполнения
кода при создании объекта.
Это участки кода, которые
используются для выполнения
логики инициализации объекта
или класса перед вызовом
конструктора или при загрузке
класса.


## 36. Математические функции. Класс Math в Java и его методы для выполнения вычислений. Примеры использования тригонометрических и экспоненциальных функций в задачах. Нужно ли создавать объект класса Math для использования математических методов.
- Метод — это группа предложений,
выполняющих определенную задачу
---
Методы
- sin(radians) Возвращает тригонометрический синус угла в радианах.
- cos(radians) Возвращает тригонометрический косинус угла в радианах.
- tan(radians) Возвращает тригонометрический тангенс угла в радианах.
- toRadians(degree) Преобразует геометрический угол из градусов в радианы.
- toDegrees(radians) Преобразует геометрический угол из радианов в градусы.
- asin(a) Возвращает угол в радианах для арксинуса.
- acos(a) Возвращает угол в радианах для арккосинуса.
- atan(a) Возвращает угол в радианах для арктангенса.
- Цифры, цифры, которые ударили мне в голову. Я получил власть, которая не снилась моему отцу.
---
Нужно ли создавать объект класса Math?
- Нет, создавать объект класса Math не нужно. Все методы являются статическими, и вы можете вызывать их напрямую через класс

## 37. Абстракция и инкапсуляция класса. Понятие абстракции как отделения реализации класса от его использования. Как эти принципы улучшают структурирование кода и его модульность? 

Абстракция и инкапсуляция — это два ключевых принципа объектно-ориентированного программирования (ООП), которые помогают разработчикам создавать более чистый, понятный и поддерживаемый код. Давайте рассмотрим каждое из этих понятий подробнее и их влияние на структурирование кода и его модульность.

Абстракция и инкапсуляция — это два ключевых принципа объектно-ориентированного программирования (ООП), которые помогают разработчикам создавать более чистый, понятный и поддерживаемый код. Давайте рассмотрим каждое из этих понятий подробнее и их влияние на структурирование кода и его модульность.

▎Абстракция

Абстракция — это процесс выделения общих характеристик объектов и скрытие сложных деталей реализации. Это позволяет разработчикам сосредоточиться на том, что делает объект, а не на том, как он это делает. 

▎Примеры абстракции:

• Интерфейсы и абстрактные классы: Они позволяют определить набор методов, которые должны быть реализованы в конкретных классах, не указывая, как именно это должно быть сделано.
• Скрытие деталей реализации: Например, в классе Car можно определить методы startEngine() и stopEngine(), не раскрывая детали того, как именно работает двигатель.

▎Преимущества абстракции:

1. Упрощение взаимодействия: Пользователи класса могут использовать его методы без необходимости понимать внутреннюю реализацию.
2. Улучшение читаемости кода: Код становится более понятным, так как акцент делается на функциональности, а не на деталях реализации.
3. Легкость в изменениях: Если реализация изменится, пользователям класса не нужно будет изменять свой код, если интерфейс остается неизменным.

▎Инкапсуляция

Инкапсуляция — это механизм ограничения доступа к внутренним данным и методам класса. Это достигается с помощью модификаторов доступа (например, private, protected, public), которые контролируют видимость членов класса.

▎Примеры инкапсуляции:

• Поля класса могут быть объявлены как private, а доступ к ним осуществляется через публичные методы (геттеры и сеттеры).
• Метод может быть объявлен как private, чтобы его нельзя было вызвать извне класса.

▎Преимущества инкапсуляции:

1. Защита данных: Инкапсуляция помогает защитить внутреннее состояние объекта от некорректного использования или изменения.
2. Упрощение отладки и тестирования: Поскольку внутренние детали скрыты, легче изолировать проблемы и тестировать отдельные компоненты.
3. Гибкость в изменениях: Внутренние реализации могут быть изменены без влияния на код, который использует класс, если интерфейсы остаются неизменными.

▎Как эти принципы улучшают структурирование кода и его модульность?
1. Четкая структура: Использование абстракции и инкапсуляции помогает создать четкую структуру приложения, где каждый класс отвечает за свою часть функциональности. Это делает код более организованным и легким для понимания.
2. Модульность: Классы, которые следуют этим принципам, становятся модулями, которые можно легко заменять или переиспользовать в других частях программы или в других проектах.
3. Снижение связности: Абстракция и инкапсуляция способствуют снижению связности между компонентами системы. Это означает, что изменения в одном компоненте меньше влияют на другие компоненты, что облегчает поддержку и развитие системы.
4. Упрощение тестирования: Модули с четко определенными интерфейсами и скрытыми внутренними деталями легче тестировать изолированно, что способствует более качественному программированию.

В целом, абстракция и инкапсуляция являются основополагающими принципами ООП, которые помогают создавать более чистый, понятный и поддерживаемый код, способствующий лучшему структурированию и модульности программных систем.

## 38. Отношения между классами. Основные виды отношений между классами: ассоциация, агрегация, композиция, наследование.
- Ассоциация — это наиболее распространенное бинарное
отношение, которое описывает взаимодействие двух классов.
- Агрегация моделирует отношения типа has-a (имеет). Объект владелец называется агрегирующим объектом, а его класс —
агрегирующим классом. Объект-субъект называется
агрегируемым объектом, а его класс — агрегируемым классом.

## 39. Ассоциация. Понятие ассоциации как бинарного отношения между классами. Примеры реализации ассоциации в Java. Как ассоциация помогает моделировать взаимодействие объектов?
- Ассоциация — это бинарное отношение между двумя классами, которое описывает, как объекты этих классов взаимодействуют друг с другом. В отличие от других отношений, таких как наследование или агрегация, ассоциация не подразумевает жесткой зависимости между классами. Это означает, что объекты одного класса могут существовать независимо от объектов другого класса.
---
Как ассоциация помогает моделировать взаимодействие объектов?

1. Определение взаимосвязей: Ассоциация позволяет четко определить, как различные объекты взаимодействуют друг с другом. Это помогает разработчикам лучше понять структуру приложения и его компоненты.
2. Моделирование реального мира: Ассоциация позволяет моделировать отношения из реального мира. Например, отношения между студентами и курсами, клиентами и заказами и т.д.
3. Гибкость: Ассоциации обеспечивают гибкость при изменении моделей. Можно добавлять или удалять связи между объектами без изменения их внутренней структуры.
4. Упрощение управления состоянием объектов: Ассоциации позволяют управлять состоянием объектов через их взаимосвязи. Например, можно легко получить список всех курсов, на которые записан студент, или всех студентов, записанных на курс.
5. Улучшение читаемости кода: Четкое определение ассоциаций между классами улучшает читаемость кода и делает его более понятным для других разработчиков.

## 40. Агрегация и композиция. Понятия агрегации и композиции, их различия. Как они отражают отношения «has-a» между объектами? Примеры реализации агрегации и композиции в проектировании классов.
- Агрегация моделирует отношения типа has-a (имеет). Объект владелец называется агрегирующим объектом, а его класс —
агрегирующим классом. Объект-субъект называется
агрегируемым объектом, а его класс — агрегируемым классом.
---
Основные различия

1. Жизненный цикл:

   • Агрегация: Объекты могут существовать независимо.
   • Композиция: Объекты не могут существовать независимо; жизнь одного зависит от жизни другого.

2. Слабая vs. сильная связь:

   • Агрегация: Слабая связь между объектами.
   • Композиция: Сильная связь между объектами.

3. Отношение "has-a":

   • Оба типа отношений выражают "has-a", но композиция подразумевает более глубокую связь.

## 41. Обработка примитивных типов как объектных. Использование классов-оберток для работы с примитивными типами как с объектами. Примеры преобразования примитивных типов в объекты и обратно. 
- Значение примитивного типа данных не является объектом, но
оно может быть «обернуто» в объект с помощью классаобертки Java API.
- Используя класс-обертку (wrapper class), можно
обрабатывать значения примитивных типов данных, таких
как объекты.

## 42. Классы-обертки. Основные возможности классов-оберток: Integer, Double, Boolean и других. Методы для преобразования значений и сравнения объектов. Примеры использования методов parseInt, valueOf и compareTo.
- Используя класс-обертку (wrapper class), можно
обрабатывать значения примитивных типов данных, таких
как объекты.
---
Основные возможности классов-оберток

1. Преобразование типов:

   • Классы-обертки позволяют преобразовывать примитивные типы в объекты и обратно. Например, можно создать объект Integer из примитивного типа int, а также получить значение int из объекта Integer.
   

2. Автоупаковка и распаковка:

   • Начиная с Java 5, компилятор автоматически выполняет упаковку (преобразование примитивного типа в объект) и распаковку (преобразование объекта обратно в примитивный тип), что упрощает работу с классами-обертками.
   

3. Методы для работы с данными:

   • Классы-обертки предоставляют различные методы для работы с данными. Например, класс Integer имеет методы для преобразования строк в числа, сравнения, нахождения максимального и минимального значений и т. д.
      

5. Сравнение объектов:

   • Классы-обертки переопределяют методы equals() и compareTo(), что позволяет сравнивать объекты классов-оберток.
   

6. Константы:

   • Каждый класс-обертка содержит константы, представляющие максимальные и минимальные значения для соответствующего примитивного типа. Например, классы Integer, Double, Boolean имеют такие константы.

7. Работа с коллекциями:

   • Классы-обертки могут быть использованы в коллекциях (например, в ArrayList, HashMap и т. д.), так как они являются объектами, в отличие от примитивных типов.


## 43. Автоматическое преобразование. Что такое автоупаковка (autoboxing) и автораспаковка (unboxing) в Java? Как они автоматически преобразуют значения примитивных типов в объекты и обратно? Примеры использования.

Автоупаковка (autoboxing) и автораспаковка (unboxing) в Java — это механизмы, позволяющие автоматически преобразовывать примитивные типы в соответствующие классы-обертки и наоборот.

▎Автоупаковка (Autoboxing) - Это процесс, при котором примитивный тип автоматически преобразуется в объект класса-обертки. Например, когда вы присваиваете int переменную объекту Integer:

▎Автораспаковка (Unboxing) - Это процесс, при котором объект класса-обертки автоматически преобразуется обратно в примитивный тип. Например:
   
Эти механизмы упрощают работу с коллекциями и делают код более читаемым.

## 44. Класс String. Понятие неизменяемости(иммутабельности) строк в Java. Как создаются объекты типа String? Примеры работы с методами создания, сравнения и модификации строк.
Класс String
- Объект типа String является неизменяемым, то есть его
содержимое нельзя изменить после создания строки.

## 45. Строки в JAVA. Замена и разделение строк. Методы класса String для замены символов и разделения строк. Примеры работы с методами replace и split.
В Java класс String предоставляет методы для работы со строками, включая замену символов и разделение строк.

▎Замена символов

Метод replace используется для замены символов или подстрок в строке.

``` Java
String original = "Hello, World!";
String replaced = original.replace("World", "Java");
System.out.println(replaced); // Вывод: Hello, Java!
```

▎Разделение строк

Метод split разбивает строку на массив подстрок по заданному разделителю.

```Java
String text = "apple,banana,cherry";
String[] fruits = text.split(",");
for (String fruit : fruits) {
    System.out.println(fruit);
}
// Вывод:
// apple
// banana
// cherry
```

▎Итоги

• replace — для замены символов или подстрок.

• split — для разделения строки на массив подстрок.

## 46. Строки в JAVA. Преобразования между строками и массивами. Как преобразовать строку в массив символов и наоборот? Примеры использования методов toCharArray и valueOf.

В Java строки представляют собой объекты класса String, который предоставляет множество методов для работы с текстовыми данными. Одним из таких методов является toCharArray(), который позволяет преобразовать строку в массив символов. Также можно использовать метод String.valueOf() для преобразования массива символов обратно в строку.

▎Преобразование строки в массив символов

Чтобы преобразовать строку в массив символов, используйте метод toCharArray(). Этот метод возвращает новый массив, содержащий символы строки.

Пример:
```Java
public class StringToCharArrayExample {
    public static void main(String[] args) {
        String str = "Hello, World!";
        char[] charArray = str.toCharArray();

        // Выводим массив символов
        System.out.println("Массив символов:");
        for (char c : charArray) {
            System.out.print(c + " ");
        }
    }
}
```

▎Преобразование массива символов в строку

Чтобы преобразовать массив символов обратно в строку, вы можете использовать конструктор класса String или метод String.valueOf(). 

Пример:
```Java
public class CharArrayToStringExample {
    public static void main(String[] args) {
        char[] charArray = {'H', 'e', 'l', 'l', 'o'};
        
        // Преобразование массива символов в строку
        String str = String.valueOf(charArray);
        
        // Альтернативный способ
        // String str = new String(charArray);

        System.out.println("Преобразованная строка: " + str);
    }
}
```

▎Использование методов toCharArray и valueOf

1. Метод toCharArray():

   • Применяется для получения массива символов из строки.

   • Пример: char[] chars = "example".toCharArray();

2. Метод String.valueOf():

   • Может использоваться для преобразования различных типов данных в строку, включая массивы символов.

   • Пример: String str = String.valueOf(chars);

▎Полный пример

Вот полный пример, который демонстрирует оба преобразования:
```Java
public class StringAndCharArrayExample {
    public static void main(String[] args) {
        // Преобразование строки в массив символов
        String originalString = "Java Programming";
        char[] charArray = originalString.toCharArray();
        
        System.out.println("Исходная строка: " + originalString);
        System.out.print("Массив символов: ");
        for (char c : charArray) {
            System.out.print(c + " ");
        }
        System.out.println();

        // Преобразование массива символов обратно в строку
        String newString = String.valueOf(charArray);
        
        System.out.println("Преобразованная строка: " + newString);
    }
}
```

▎Вывод программы

Исходная строка: Java Programming

Массив символов: J a v a   P r o g r a m m i n g 

Преобразованная строка: Java Programming


Таким образом, вы можете легко преобразовывать строки в массивы символов и обратно с помощью методов toCharArray() и String.valueOf().

## 47. Строки в JAVA. Класс StringBuilder и StringBuffer. Понятие изменяемых строк. Основные отличия между StringBuilder и StringBuffer. Примеры их использования. Влияние классов StringBuilder и StringBuffer на типобезопасность.
- В Java строки представлены классом String, который является неизменяемым (immutable). Это означает, что после создания объекта String его содержимое не может быть изменено. Однако для работы с изменяемыми строками Java предоставляет два класса: StringBuilder и StringBuffer. Эти классы позволяют создавать строки, которые можно изменять, добавлять к ним текст и выполнять другие операции без создания новых объектов.

▎Класс StringBuilder

- StringBuilder — это класс для работы с изменяемыми строками. Он более эффективен по сравнению с StringBuffer, так как не синхронизирован, что делает его предпочтительным выбором для однопоточных приложений.

▎Класс StringBuffer

- StringBuffer также представляет собой изменяемую строку, но он синхронизирован, что делает его потокобезопасным. Это означает, что несколько потоков могут безопасно работать с одним и тем же объектом StringBuffer.
---
▎Основные отличия между StringBuilder и StringBuffer

1. Потокобезопасность:

   • StringBuffer — потокобезопасен (синхронизирован).

   • StringBuilder — не потокобезопасен (не синхронизирован).

2. Производительность:

   • StringBuilder обычно быстрее, чем StringBuffer, из-за отсутствия синхронизации.

   • StringBuffer медленнее из-за дополнительных накладных расходов на синхронизацию.

3. Использование:

   • StringBuilder рекомендуется использовать в однопоточных средах.

   • StringBuffer рекомендуется использовать в многопоточных средах, где требуется безопасность потоков.

## 48. Строки в JAVA. Преобразование символов и чисел в строки. Какие методы используются для преобразования чисел, символов и объектов в строки? Примеры работы с методами String.valueOf() и toString().

## 49. Строки в JAVA. Интернированные строки. Что такое интернированные строки? Как JVM оптимизирует работу с повторяющимися строками? Примеры их использования.

## 50. Наследование в JAVA. Основные принципы наследования в Java. Что такое суперклассы(родительские) и подклассы(дочерние)? Как наследование помогает переиспользовать код? Примеры реализации наследования.
Суперклассы и подклассы
- Объектно-ориентированное программирование позволяет
определять новые классы из уже существующих, т.е. можно
определить более общий класс (т.е. суперкласс) и позже
породить от него более конкретные (т.е. подклассы). Это
называется наследованием.

o Подкласс не является подмножеством своего суперкласса

o Скрытые поля данных суперкласса нельзя использовать в подклассе
напрямую

o Наследование используется для моделирования отношения is-a

o Не все отношения is-a должны моделироваться с помощью
наследования

o Java-класс может напрямую наследоваться только от одного суперкласса

## 51. Перегрузка метода в Java (overload). Переопределение метода в Java (override). В чем разница между перегрузкой и переопределением методов.
## 52. Наследование и отношение is-a. Как наследование реализует отношение «is-a»? Когда использование наследования может быть нецелесообразным? Примеры решений.
## 53. Ключевое слово super. Роль ключевого слова super в Java. Использование для вызова методов и конструкторов суперкласса. Примеры реализации.
## 54. Цепочка конструкторов. Понятие цепочки конструкторов. Как вызвать один конструктор из другого с использованием this() и super()? Примеры реализации.
## 55. Класс Object и его основные методы. Роль класса Object как суперкласса для всех классов в Java. Как метод toString() используется для представления объекта в виде строки? Примеры переопределения метода.
## 56. Полиморфизм. Понятие полиморфизма в Java. Как переменная супертипа может ссылаться на объект подтипа? Примеры применения полиморфизма для создания гибкого кода.

## 57. Интерфейсы в Java. Понятие интерфейсов как конструкций для определения общих операций. Основные элементы интерфейсов: константы и абстрактные методы. Примеры использования интерфейсов для создания обобщенных решений.
## 58. Интерфейсы в Java. Понятие интерфейсов как конструкций для определения общих операций. Особенности интерфейсов, добавленные в JAVA 8 версии. Дефолтные методы в интерфейсах.
## 59. Интерфейсы в Java. Особенности интерфейсов. Чем интерфейсы отличаются от классов? Как используются ключевые слова interface и implements? Примеры объявления и реализации интерфейсов.
## 60. Интерфейсы в Java 8 и 9. Новые возможности интерфейсов, такие как default и static методы (Java 8), а также private и private static методы (Java 9). Примеры реализации и применения.
## 61. Интерфейс Comparable. Как интерфейс Comparable используется для сравнения объектов? Реализация метода compareTo() и его роль в сортировке. Примеры работы с интерфейсом.
## 62. Интерфейс Comparable для классов стандартной библиотеки JAVA. Как реализован интерфейс Comparable в классах String, Integer и Date? Примеры сравнения объектов с помощью метода compareTo().
## 63. Интерфейс Comparable для пользовательских классов. Как реализовать интерфейс Comparable для пользовательских классов? Примеры сравнения объектов на основе пользовательских критериев.
## 64. Интерфейс Cloneable. Понятие клонирования объектов. Как интерфейс Cloneable позволяет клонировать объекты? Ограничения и примеры использования.
## 65. Метод clone(). Как метод clone(), определенный в классе Object, используется совместно с интерфейсом Cloneable? Примеры работы с клонируемыми объектами.
## 66. Интерфейсы и абстрактные классы. Основные различия между интерфейсами и абстрактными классами. 
## 67. Понятие абстрактных классов в Java. Что такое абстрактный класс, и как он используется для создания общего базового поведения? Чем отличается абстрактный класс от интерфейса? Примеры объявления и реализации абстрактного класса с абстрактными и конкретными методами.
## 68. Понятие абстрактных классов в Java. Объявление абстрактных методов. Что такое абстрактный метод, и какие правила нужно соблюдать при его объявлении? Как абстрактные методы помогают подклассам реализовать специфическое поведение? Примеры реализации абстрактных методов в наследуемых классах.
## 69. Понятие абстрактных классов в Java. Особенности работы с абстрактными классами. Почему абстрактные классы нельзя инстанцировать? Как использовать абстрактный класс как основу для других классов? Примеры создания иерархии классов с базовым абстрактным классом.
## 70. Ограничение множественного наследования в JAVA. Множественное наследование интерфейсов. Как классы наследуют методы от нескольких интерфейсов.
## 71. Интерфейсы в Java. Особенности интерфейсов. Интерфейсы и полиморфизм. Как интерфейсы способствуют реализации полиморфизма?

## 72. Обработка исключительных ситуаций в JAVA. Основные способы и подходы к обработке исключительных ситуаций в JAVA. Иерархия классов исключений в Java. Понятие и структура иерархии исключений. Чем отличаются классы Error, Exception и RuntimeException?
## 73. Создание и генерация исключений. Как создавать и генерировать исключения с помощью ключевого слова throw? Различия между throw и throws. Примеры создания пользовательских исключений.
## 74. Обработка исключений. Структура блока try-catch. Как обрабатывать исключения с использованием блоков try-catch? Примеры обработки нескольких исключений и упорядочения блоков catch. Роль объекта исключения (Exception e) в блоке catch.
## 75. Обработка исключений. Структура блока try-catch. Блок finally и его использование. Основные причины использования. Примеры использования.
## 76. Обработка исключений. Пропагирование исключений. Как исключения передаются вверх по стеку вызовов? Примеры использования ключевого слова throws в сигнатуре методов.
## 77. Обработка исключений. Проверяемые и непроверяемые исключения. Какие исключения считаются проверяемыми (checked), а какие - непроверяемыми (unchecked)? Примеры работы с ними. Исключения в популярных фреймворках. Почему большинство исключений в современных фреймворках являются непроверяемыми?
## 78. Обработка исключений. Использование try-with-resources. Как она упрощает управление ресурсами? Примеры работы.
## 79. Обработка исключитеьных ситуаций в JAVA. Роль JVM в обработке исключений. Как JVM управляет исключениями, если они не были обработаны? Примеры поведения при неперехваченных исключениях.
## 80. Перечисления (enums) в Java. Что такое перечисления и как они используются для создания фиксированных наборов значений? Характеристики перечислений. Перечисления и типобезопасность. Примеры их применения.
## 81. GUI в Java. Что такое GUI (графический пользовательский интерфейс)? Основные пакеты для работы с GUI в Java: AWT и Swing.
## 82. GUI в Java. Структура GUI в JAVA при реализации через Swing и AWT. Компоненты GUI. Какие элементы составляют графический интерфейс? Примеры кнопок, текстовых полей и других компонентов.
## 83. AWT (Abstract Window Toolkit). Что такое AWT и как он используется для создания GUI? Примеры простых интерфейсов с использованием AWT.
## 84. Swing в Java. Как Swing расширяет возможности AWT? Примеры создания интерфейсов с использованием Swing. Паттерн MVC в Swing. Как Swing реализует модель MVC (Model-View-Controller)? Примеры разделения логики, представления и управления в интерфейсе.
## 85. Структура GUI в Java. Основные компоненты GUI в Swing: контейнеры (JFrame, JPanel, JDialog), компоненты (JButton, JLabel, JTextField) и менеджеры компоновки. 
## 86. Класс JFrame. Что такое окно JFrame, и как использовать его для создания графического интерфейса? Примеры добавления элементов через метод getContentPane().
## 87. Класс JPanel. Как панель JPanel используется для группировки и управления компонентами? Примеры изменения менеджера компоновки с помощью метода setLayout().
## 88. Менеджеры компоновки в Java. Роль менеджеров компоновки в управлении размещением компонентов. Примеры использования менеджеров FlowLayout, BorderLayout, GridLayout.
## 89. Менеджер FlowLayout. Как работает FlowLayout? Примеры настройки выравнивания и промежутков между компонентами.
## 90. Менеджеры компоновки в Java. Роль менеджеров компоновки в управлении размещением компонентов. Примеры использования менеджеров FlowLayout, BorderLayout, GridLayout.
## 91. Менеджер FlowLayout. Как работает FlowLayout? Примеры настройки выравнивания и промежутков между компонентами.
## 92. Менеджер BorderLayout. Как BorderLayout делит контейнер на регионы (NORTH, SOUTH, EAST, WEST, CENTER)? Примеры создания интерфейсов с четкой организацией областей.
## 93. Менеджер GridLayout. Как компоненты размещаются в сетке с использованием GridLayout? Примеры создания таблиц или форм.
## 94. Менеджер BoxLayout. Как компоненты размещаются по горизонтали или вертикали с помощью BoxLayout? Примеры последовательного расположения элементов.
## 95. Границы в Swing. Как использовать границы для улучшения внешнего вида интерфейса? Примеры применения границ.
## 96. GUI и сбытийная модель в Java. Что такое событийная модель, и как она используется для взаимодействия компонентов через события? Основные элементы событийной модели.
## 97. Обработка событий в Java. Как источник события, слушатель и обработчик взаимодействуют в событийной модели? Примеры добавления слушателей событий. Модель делегирования событий. Как работает модель делегирования событий? 
## 98. Обработка событий при реализации GUI в JAVA. Классы событий пакета java.awt.event. Какие классы событий предоставляет пакет java.awt.event? Примеры обработки событий мыши и клавиатуры.
## 99. Обработка событий мыши в JAVA. Как использовать интерфейсы MouseListener и MouseMotionListener для обработки событий мыши? Примеры обработки нажатий и перемещений.
## 100. Обработка событий клавиатуры в JAVA. Как обрабатывать события клавиатуры с использованием KeyListener? Примеры регистрации слушателей клавиатурных событий.
## 101. Обобщённое программирование в Java. Понятие обобщённого программирования и его роль в упрощении создания алгоритмов для работы с различными типами данных. История разваития в JAVA. Примеры проектирования универсальных структур данных и алгоритмов.
## 102. Generics в Java. Реализация обобщенного программирования через Generics. Основные синтаксические конструкции: параметры типов, обобщенные классы и методы. Примеры работы с параметризованными классами и методами. Примущества и недостатки Generics.
## 103. Коллекции и Generics в Java. Как использование Generics повысило типобезопасность коллекций, таких как ArrayList, HashMap и HashSet? Примеры создания и обработки коллекций с обобщениями.
## 104. Параметризованные методы. Понятие параметризованных методов в Java. Как они позволяют работать с любыми типами данных? Примеры реализации методов с обобщенными параметрами и их вызова.
## 105. Generics в Java. Типовые ограничения в Generics. Как задать ограничения на параметры типов с помощью ключевых слов extends и super? Примеры их использования для обеспечения гибкости и безопасности обобщений.
## 106. Обобщенные интерфейсы. Использование Generics для создания универсальных интерфейсов. Примеры реализации обобщенных интерфейсов и их применения в реальных задачах.
## 107. Generics в Java. Подстановочные знаки (Wildcards). Как использовать ?, <? extends T> и <? super T> для работы с коллекциями? Примеры их применения.
## 108. Generics в Java. Стирание типов (Type Erasure). Как информация о Generics удаляется во время компиляции? Примеры преобразования Generics в сырой тип.
## 109. Коллекции в Java. Понятие коллекций как структур данных для хранения объектов. Основные интерфейсы и классы в Java Collections Framework (JCF). Примеры использования коллекций для хранения и обработки данных.
## 110. Иерархия коллекций. Структура иерархии коллекций в Java. Основные интерфейсы (Collection, List, Set, Map) и их ключевые особенности. Примеры реализации различных типов коллекций.
## 111. LinkedList в Java. Особенности класса LinkedList как реализации интерфейса List. Преимущества использования. 
## 112. Коллекции в Java. Понятие коллекций как структур данных для хранения объектов. Основные цели использования коллекций. Роль Iterable в Java Collections Framework. 
## 113. Коллекции в Java. Реализации List - ArrayList. Особенности функционирования ArrayList. Пример использования ArrayList.
## 114. Коллекции в Java. Создание Generic Collection в Java. Преимущства данного подхода. Примеры. 
## 115. Коллекции и Generics. Использование Generics для типобезопасности в коллекциях. Примеры создания типизированных списков и множеств.
## 116. ArrayList в Java. Понятие ArrayList как реализации интерфейса List. Основные методы (add, get, remove) для работы со списками. Примеры добавления, удаления и доступа к элементам.
## 117. Задача на выполнение


